# -*- coding: utf-8 -*-
__author__ = "Kramer84"
__all__ = [
    "OptimizationStorage",
]

import numpy as np
import logging
from scipy.optimize import basinhopping, minimize


class OptimizationStorage:
    """
    Class to store, manage, and analyze optimization data. This class keeps track of points explored during optimization,
    whether generated by a global or local optimizer, and verifies if the points respect user-defined constraints and bounds.

    Key Features:
    -------------
    - Stores each point's coordinates and the corresponding objective function value.
    - Tracks whether each point was generated by a local or global optimization method.
    - Automatically checks if points respect user-specified variable bounds.
    - Evaluates whether points satisfy given constraints (passed via a constraint function).
    - Offers utility methods to filter, manage, and query stored data.

    Parameters:
    -----------
    bounds : list of tuple or None, optional
        List of tuples defining (lower, upper) bounds for each variable. If None, no bounds are applied (default: None).
    constraint_function : callable or None, optional
        A function that takes a point (array-like) as input and returns a boolean indicating whether the point satisfies
        the constraints (True if satisfied, False otherwise). If None, no constraints are applied (default: None).

    Attributes:
    -----------
    data : pandas.DataFrame
        A DataFrame that stores optimization points and related metadata, with the following columns:
        - 'point' : array-like, the coordinates of the explored point.
        - 'function_value' : float, the value of the objective function at the given point.
        - 'source' : str, whether the point was generated from a local or global optimizer ('local' or 'global').
        - 'bounds_respected' : bool, whether the point respects the variable bounds.
        - 'constraints_respected' : bool, whether the point satisfies the constraint function.

    Methods:
    --------
    add_point(x, f, source):
        Adds a new optimization point with its function value, source, and checks for bounds and constraints compliance.

    check_bounds(x):
        Verifies if a point respects the variable bounds.

    check_constraints(x):
        Verifies if a point satisfies the constraint function.

    apply_checks_to_all():
        Reapplies bounds and constraints checks to all stored points, updating the DataFrame.

    get_all_data():
        Returns the complete DataFrame of stored optimization points.

    get_points_by_source(source):
        Filters and returns points generated by either the local or global optimizer.

    clear_storage():
        Clears the stored data while retaining the DataFrame structure.
    """

    def __init__(self, bounds=None, constraint_function=None):
        # Create an empty DataFrame with the desired columns
        self.data = pd.DataFrame(
            columns=[
                "point",
                "function_value",
                "source",
                "bounds_respected",
                "constraints_respected",
            ]
        )
        self.bounds = bounds  # (min, max) for each variable
        self.constraint_function = constraint_function  # Function to check constraints
        logging.info(
            "OptimizationStorage initialized with bounds: %s and constraint_function: %s",
            self.bounds,
            self.constraint_function,
        )

    def add_point(self, x, f, source):
        """
        Add a point, its function value, and its source (local or global) to the DataFrame.
        """
        logging.info(
            "Attempting to add point: %s with function value: %f from source: %s", x, f, source
        )
        bounds_respected = self.check_bounds(x)
        constraints_respected = self.check_constraints(x)

        if np.isnan(f):
            logging.warning("Attempting to add NaN function value for point: %s", x)
            print(f"Warning: NaN function value detected for point: {x}")

        new_entry = pd.DataFrame(
            {
                "point": [np.copy(x)],
                "function_value": [f],
                "source": [source],
                "bounds_respected": [bounds_respected],
                "constraints_respected": [constraints_respected],
            }
        )

        self.data = pd.concat([self.data, new_entry], ignore_index=True)

    def check_bounds(self, x):
        """
        Check if the point respects the bounds.
        """
        if self.bounds is None:
            return True

        # Use the residual method from the Bounds object to check feasibility
        sl, sb = self.bounds.residual(x)

        # If any sl or sb are negative, the point is out of bounds
        return np.all(sl >= 0) and np.all(sb >= 0)

    def check_constraints(self, x):
        """
        Check if the point respects the constraints.
        """
        if self.constraint_function is None:
            return True

        return self.constraint_function(x)

    def apply_checks_to_all(self):
        """
        Apply bounds and constraint checks to all entries in the DataFrame.
        """
        self.data["bounds_respected"] = self.data["point"].apply(self.check_bounds)
        self.data["constraints_respected"] = self.data["point"].apply(self.check_constraints)

    def get_all_data(self):
        """Return the entire DataFrame with all stored points."""
        return self.data

    def get_points_by_source(self, source):
        """
        Return points filtered by their source (local or global).
        """
        return self.data[self.data["source"] == source]

    def clear_storage(self):
        """Clear the DataFrame."""
        self.data = self.data.iloc[0:0]  # Clear the DataFrame by keeping the structure

    # New method for filtering points
    def filter_points(self, source=None, bounds_respected=None, constraints_respected=None):
        """
        Filter the points based on source, bounds compliance, and constraint compliance.

        Parameters:
        -----------
        source : str, optional
            Filter by the source of the point ('local' or 'global').
        bounds_respected : bool, optional
            Filter by whether the bounds were respected.
        constraints_respected : bool, optional
            Filter by whether the constraints were respected.

        Returns:
        --------
        pd.DataFrame
            A DataFrame filtered according to the provided criteria.
        """
        df = self.data
        logging.info(
            "Filtering points with source=%s, bounds_respected=%s, constraints_respected=%s",
            source,
            bounds_respected,
            constraints_respected,
        )

        if source is not None:
            df = df[df["source"] == source]

        if bounds_respected is not None:
            df = df[df["bounds_respected"] == bounds_respected]

        if constraints_respected is not None:
            df = df[df["constraints_respected"] == constraints_respected]

        return df

    # Adding iterator functionality
    def __iter__(self):
        """
        Iterate over all points in the storage by default.
        """
        return self.data.iterrows()

    def iter_points(self, source=None, bounds_respected=None, constraints_respected=None):
        """
        Generator for iterating over points based on specific filters.

        Parameters:
        -----------
        source : str, optional
            Iterate over points filtered by their source ('local' or 'global').
        bounds_respected : bool, optional
            Iterate over points filtered by whether bounds were respected.
        constraints_respected : bool, optional
            Iterate over points filtered by whether constraints were respected.

        Yields:
        -------
        index : int
            Index of the point in the DataFrame.
        row : pd.Series
            Row from the DataFrame with point information.
        """
        filtered_df = self.filter_points(source, bounds_respected, constraints_respected)
        for index, row in filtered_df.iterrows():
            yield index, row
